---
title: Каталог товаров
categories: [angular]
comments: false
---
# Каталог товаров
1. [Обмен данными через EventEmitter](#EventEmitter)
2. [Структурные директивы](#Structural)
3. [Директивы *ngIf и *ngSwitch](#ngIf)
4. [Директива цикла *ngFor](#ngFor)
5. [Преобразование данных через Pipes](#pipe)
6. Карточка товара

В этой главе поговорим о передаче данных от дочернего компонента к родительскому. Подробнее обсудим что такое директивы и с помощью
них научимся управлять структурой документа. А после разберём как форматировать данные в удобно
читаемый вид.

## <a name="EventEmitter">Обмен данными через EventEmitter</a>

Для того чтобы передать данные от потомка к родителю применяется `EventEmitter`. При помощи него можно создавать 
пользовательские события и передавать родителю произвольные данные. 

{% raw %}
```ts
@Component({
    selector: 'app-tabs',
    template: `<app-tab [value]="value" (click)="select(value)"></app-tab>`,
})
export class TabsComponet {
    @Output() selected: EventEmitter = new EventEmitter();
    ...
    select(val) {
        this.selected.emit(val);
    }
}
```
{% endraw %}

`EventEmitter` обычно применяется в паре с декоратором `Output()` который является альтернативой `Input()` для передачи данных в обратном направлении.
`Output()` декарирует свойство содержащий `EventEmitter`. `EventEmitter` в свою очередь является создаваемой сущностью и перед использованием его нужно явно создать.

Теперь поговорим о вызове событий. Вызов свойства содержащего `EventEmitter` происходит из метода обработчика "клика".
Из данного метода вызывается `emit` в котором передаётся аргумент значения активной опции.

Проговорим полученный алгоритм. Каждый раз при клике на опцию помимо обновлений значений в контейнере
происходит вызов `EventEmitter` ему передаётся обновленное значение. Давайте посмотрим как это обрабатывать в родительском компоненте:

{% raw %}
```ts
@Component({
    selector: 'app-catalog-pages',
    template: `<app-tabs [tabs]="tabs" (selected)="select($event)"></app-tabs>`,
})
export class CatalogPagesComponent {
    ...
    select(val) {
        ...
    }
}
```
{% endraw %}

Для привязки события используется синтаксис с круглыми скобками `(selected)="select($event)`. Данный синтаксис точно такой же как и для обработки DOM событий.
Через знак равно указывается метод который будет вызываться при каждом `emit`. И если `EventEmitter`
содержит данные, то мы можем передавать их обработчику используя привычный `$event`.

## <a name="Structural">Структурные директивы</a>

Разбираясь в способаз стилизации мы впервые попробовали директивы. В Angular имеется два типа встроенных директив:

| тип директивы | Описание                                      |
|---------------|-----------------------------------------------|
| `атрибутные`  | Управляет стилями как `ngStyle` или `ngClass` |
| `структурные` | Управляет структурой файла без применения CSS |

Структурных директив всего три:

| директива       | Описание                                                      |
|-----------------|---------------------------------------------------------------|
| `*ngIf`         | Удаляет или добавляет элемент на основе значения              |
| `*ngSwitchCase` | Тоже что и `*ngIf` только с синтаксисом switch/case           |
| `*ngForOf`      | Перебирает в шаблоне массив и добавляет элемент на каждый шаг |

Все они позволяют рещать задачи легко и экономит время. Структурную директиву легко распознать в шаблоне с помощью синтаксиса.
Перед названием директивы всегда имеется `*`. Вообще в мире Angular директивы используются чаще чем компоненты, т.к. они позволяют не плодить лишний код и 
делают HTML по настоящему могучим. Разработка не ограничивается встроенными директивами и разработчики постоянно делают собственные.
При помощи директив можно обрабатывать DOM события, получать доступ к компоненту или менять его свойства. Еще можно создавать компонент динамически.
Образно говоря директиву можно представить как компонент без шаблонов и стилей, но вместо этого может подключаться к любому другому шаблону. Пока мы будем учиться работать со структурными директивами.

## <a name="ngIf">Директивы *ngIf и *ngSwitch</a>

Чтобы лучше понимать как работает `*ngIf` давайте снова проведём аналогию с JS. 

```ts
function createButton(text) {
    const control = document.createElement('button');
    control.className = 'primary';
    control.innerHTML = `<span>${text}</span>`
}

const container = // select div
const button = createButton('text');
if (values) {
    container.append(button);
} else {
    container.remove();
}
```

Давайте представим, что добавление в DOM button происходит в зависимости от содержимого values.
В случае наличия данных происходит вставка button в DOM дерево, а в случае отсутвия values происходит удаление button из Dom дерева.

Теперь сравним как это можно реализовать в Angular:

```html
<button class="primary" *ngIf="values">
    <span>Update</span>
</button>
```

Тут мы добавили кнопку в шаблон и с помощью директивы `*ngIf` управляем добавлением/удалением кнопки в шаблоне.

```html
<button class="primary" *ngIf="getValue()">
    <span>Update</span>
</button>

<button *ngIf="isLoggedIn && hasRole('admin')">
</button>

<div class="container" *ngIf="data.id === 13"></div>
```

`*ngIf` очень мощный и рдновременно очень простой инструмент который экономит нам кучу времени. Его можно применять к Angular компонентам так и просто к HTML. 
Директиве можно передавать готовые значения так и логические выражения.

Теперь давайте представим такую задачу. Мы используем JS и создаём фабрику компонентов:

```ts
...
if (type === 'button') { return createButton() }
if (type === 'card') { return createCard() }
...
switch(type){
    case 'button': return createButton();
    case 'card': return createCard(); 
}
```
Можно использовать `if` но такой код весьма избыточный и поэтому мы воспользуемся оператором `switch`.

Так же и со структурными директивами. Для таких случаев имеется структурная директива `ngSwitch`:

```html
...
<div class="container" [ngSwitch]="type">
    <app-button *ngSwitchCase="'button'"></app-button>
    <app-card *ngSwitchCase="'card'"></app-card>
    <app-default *ngSwitchDefault></app-default>
</div>
```

В `[ngSwitch]="type"` передаётся аргумент и если данный аргумент совпадёт со значениями содержащиемеся `*ngSwitchCase`, то в DOM отобразиться именно этот элемент, а иначе `default` элемент.

## <a name="ngFor">Директива цикла *ngFor</a>

Ещё одна популярная задача frontend разработки - это рендеринг компонентов на основе списка.
Представим, что у нас имеется список товаров и нам нужно вывести каарточки на основании данного списка.
Вот так бы это выглядело на JS:

```js
...

const container = // select div
const products = [{...}, {...}, {...}];

function createCard(product) {
    ...
}

for (let product of products) {
    const card = this.createCard(product);
    container.append(card);
}
```

В Ангуляре для таких задач существует директива `ngForOf`. Чтобы вывести каталог на основе списка нужно
в шаблоне применить `ngFor` компоненту карточки и указать выражение аналогичное `forOf` JS. 

```html
<div class="list">
    <app-element *ngFor="let item of list"></app-element>
</div>
```

Помимо вывода каждого элемента списка директива `*ngForOf` может задавать жополнительные переменные:

| Имя     | Описание                                                                                                    |
|---------|-------------------------------------------------------------------------------------------------------------|
| `index` | Зачение типа number; содержит позицию текущего объекта                                                      |
| `odd`   | Чение типа boolean; возвращает true, если текущий объект находится в нечётной позиции источника данных      |
| `event` | Зачение типа boolean; возвращает true, если текущий объект находится в чётной позиции источника данных      |
| `first` | Значение типа boolean; возвращает true, если текущий объект находится в пер-вой позиции источника данных    |
| `last`  | Значение типа boolean; возвращает true, если текущий объект находится в по-следней позиции источника данных |

{% raw %}
```html
<table class="table table-sm table-bordered m-t-1">
    <tr><th></th><th>Name</th><th>Category</th><th>Price</th></tr>
    <tr *ngFor="let item of getProducts(); let i = index">
        <td>{{i +1}}</td>        
        <td>{{item.name}}</td> 
        <td>{{item.category}}</td>   
        <td>{{item.price}}</td> 
    </tr>
</table>
```
{% endraw %}


## <a name="pipe">Преобразование данных через Pipes</a>

При работе с данными разработчикам часто приходится прибегать к преобразованиям. Например пользователям всегда проще воспринимать отформатированные данные - это могут быть дата, валюта и т.д. В JS нам бы пришлось писать функции для форматирования. В Angular существуют `pipes`.

`Angular Pipes` - это функции которые применяются к свойству и трансформируют его.

Разработчики Angular позаботились о нас и добавили встроенные `pipes` обрабатывающие наиболее популярные случаи.

Рассмотрим примеры:

{% raw %}
```html
1. Date transform: <div>{{brithday | date: 'E, MMMM d, y }}</div>
// Вывод: Wed, 14 September 2016
2. Number transform: <div>{{price | currency}}</div>
// Вывод: $10 000
3. Float transform: <div>{{ 0.17 | percent }}</div>
// Вывод: 17%
4. Text transform: <p>{{ text | uppercase}}</p>
// Вывод: UPPERCASE TEXT
```
{% endraw %}
